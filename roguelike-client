#!/usr/bin/python3

import curses
import os
import signal
import time


from client.config.world_data import world_data
from client.config.io import io
from client.config.commands import commands
from client.config.windows import windows_config
from client.query_mapcell import query_mapcell


import types
class Window:
    def __init__(self, title, draw_function, size):
        self.title = title
        self.draw = types.MethodType(draw_function, self)
        self.size = size


def set_window_geometries():

    def size_window(config):
        size = [0, 0]
        size[0] = config[0]
        if (config[0] == 0):
            size[0] = screen_size[0] - sep_size
        elif (config[0] < 0):
            size[0] = screen_size[0] + config[0] - sep_size
        size[1] = config[1]
        if (config[1] == 0):
            size[1] = screen_size[1]
        elif (config[1] < 0):
            size[1] = screen_size[1] + config[1]
        return size

    def place_window(win):
        win_i = windows.index(win)

        # If win is first window, it goes into the top left corner.
        win.start = [0 + sep_size, 0]
        if (win_i > 0):

            # If not, get win's closest predecessor starting a new stack on the
            # screen top,fit win's top left to that win_top's top right corner.
            win_top = None
            for i in range(win_i - 1, -1, -1):
                win_top = windows[i]
                if (win_top.start[0] == 0 + sep_size):
                    break
            win.start[1] = win_top.start[1] + win_top.size[1] + sep_size

            # If enough space is found below win's predecessor, fit win's top
            # left corner to that predecessor's bottom left corner.
            win_prev = windows[win_i - 1]
            next_free_y = win_prev.start[0] + win_prev.size[0] + sep_size
            if (win.size[1] <= win_prev.size[1] and
                    win.size[0] <= screen_size[0] - next_free_y):
                win.start[1] = win_prev.start[1]
                win.start[0] = next_free_y

            # If that fails, try to fit win's top left corner to the top right
            # corner of its closest predecessor win_test 1) below win_top (see
            # above) 2) and with enough space open to its right between its
            # right edge and the lower edge of a win_high located directly
            # above win_test to fit win there (without growing further to the
            # right than win_high does or surpassing the screen's lower edge).
            else:
                win_test = win_prev
                win_high = None
                while (win_test != win_top):
                    for i in range(win_i - 2, -1, -1):
                        win_high = windows[i]
                        if win_test.start[0] > win_high.start[0]:
                            break
                    next_free_y = win_high.start[0] + win_high.size[0] \
                        + sep_size
                    first_free_x = win_test.start[1] + win_test.size[1] \
                        + sep_size
                    last_free_x = win_high.start[1] + win_high.size[1]
                    if (win.size[0] <= screen_size[0] - next_free_y and
                            win.size[1] <= last_free_x - first_free_x):
                        win.start[1] = first_free_x
                        win.start[0] = next_free_y
                        break
                    win_test = win_high

    global screen_size, stdscr
    curses.endwin()
    stdscr = curses.initscr()
    screen_size = stdscr.getmaxyx()
    for config in windows_config:
        size = size_window(config["config"])
        window = Window(config["title"], config["func"], size)
        windows.append(window)
        place_window(window)
    cursed_main.redraw = True


def draw_screen():

    def healthy_addch(y, x, char, attr=0):
        """Workaround for <http://stackoverflow.com/questions/7063128/>."""
        if y == screen_size[0] - 1 and x == screen_size[1] - 1:
            char_before = stdscr.inch(y, x - 1)
            stdscr.addch(y, x - 1, char, attr)
            stdscr.insstr(y, x - 1, " ")
            stdscr.addch(y, x - 1, char_before)
        else:
            stdscr.addch(y, x, char, attr)

    def draw_window_border_lines():
        for win in windows:
            for k in range(2):
                j = win.start[int(k == 0)] - sep_size
                if (j >= 0 and j < screen_size[int(k == 0)]):
                    start = win.start[k]
                    end = win.start[k] + win.size[k]
                    end = end if end < screen_size[k] else screen_size[k]
                    if k:
                        [healthy_addch(j, i, '-') for i in range(start, end)]
                    else:
                        [healthy_addch(i, j, '|') for i in range(start, end)]

    def draw_window_border_corners():
        for win in windows:
            up = win.start[0] - sep_size
            down = win.start[0] + win.size[0]
            left = win.start[1] - sep_size
            right = win.start[1] + win.size[1]
            if (up >= 0 and up < screen_size[0]):
                if (left >= 0 and left < screen_size[1]):
                    healthy_addch(up, left, '+')
                if (right >= 0 and right < screen_size[1]):
                    healthy_addch(up, right, '+')
            if (down >= 0 and down < screen_size[0]):
                if (left >= 0 and left < screen_size[1]):
                    healthy_addch(down, left, '+')
                if (right >= 0 and right < screen_size[1]):
                    healthy_addch(down, right, '+')

    def draw_window_titles():
        for win in windows:
            title = " " + win.title + " "
            if len(title) <= win.size[1]:
                y = win.start[0] - 1
                start_x = win.start[1] + int((win.size[1] - len(title))/2)
                for x in range(len(title)):
                    healthy_addch(y, start_x + x, title[x])

    def draw_window_contents():
        def draw_winmap():
            """Draw winmap in area delimited by offset, winmap_size.

            The individuall cell of a winmap is interpreted as either a single
            character element, or as a tuple of character and attribute,
            depending on the size len(cell) spits out.
            """
            stop = [0, 0]
            for i in range(2):
                stop[i] = win.size[i] + offset[i]
                if stop[i] >= winmap_size[i]:
                    stop[i] = winmap_size[i]
            for y in range(offset[0], stop[0]):
                for x in range(offset[1], stop[1]):
                    cell = winmap[y * winmap_size[1] + x]
                    attr = 0
                    if len(cell) > 1:
                        attr = cell[1]
                        cell = cell[0]
                    y_in_screen = win.start[0] + (y - offset[0])
                    x_in_screen = win.start[1] + (x - offset[1])
                    if (y_in_screen < screen_size[0]
                            and x_in_screen < screen_size[1]):
                        healthy_addch(y_in_screen, x_in_screen, cell, attr)
        def draw_scroll_hints():
            def draw_scroll_string(n_lines_outside):
                hint = ' ' + str(n_lines_outside + 1) + ' more ' + unit + ' '
                if len(hint) <= win.size[ni]:
                    non_hint_space = win.size[ni] - len(hint)
                    hint_offset = int(non_hint_space / 2)
                    for j in range(win.size[ni] - non_hint_space):
                        pos_2 = win.start[ni] + hint_offset + j
                        x, y = (pos_2, pos_1) if ni else (pos_1, pos_2)
                        healthy_addch(y, x, hint[j], curses.A_REVERSE)
            def draw_scroll_arrows(ar1, ar2):
                for j in range(win.size[ni]):
                    pos_2 = win.start[ni] + j
                    x, y = (pos_2, pos_1) if ni else (pos_1, pos_2)
                    healthy_addch(y, x, ar1 if ni else ar2, curses.A_REVERSE)
            for i in range(2):
                ni = int(i == 0)
                unit = 'rows' if ni else 'columns'
                if (offset[i] > 0):
                    pos_1 = win.start[i]
                    draw_scroll_arrows('^', '<')
                    draw_scroll_string(offset[i])
                if (winmap_size[i] > offset[i] + win.size[i]):
                    pos_1 = win.start[i] + win.size[i] - 1
                    draw_scroll_arrows('v', '>')
                    draw_scroll_string(winmap_size[i] - offset[i]
                        - win.size[i])
        for win in windows:
            offset, winmap_size, winmap = win.draw()
            draw_winmap()
            draw_scroll_hints()

    stdscr.erase()
    draw_window_border_lines()
    draw_window_border_corners()
    draw_window_titles()
    draw_window_contents()
    stdscr.refresh()


def read_worldstate():
    if not os.access(io["path_worldstate"], os.F_OK):
        msg = "No world state file found at " + io["path_worldstate"] + "."
        raise SystemExit(msg)
    read_anew = False
    worldstate_file = open(io["path_worldstate"], "r")
    turn_string = worldstate_file.readline()
    if int(turn_string) != world_data["turn"]:
        read_anew = True
    if not read_anew: # In rare cases, world may change, but not turn number.
        mtime = os.stat(io["path_worldstate"])
        if mtime != read_worldstate.last_checked_mtime:
            read_worldstate.last_checked_mtime = mtime
            read_anew = True
    if read_anew:
        cursed_main.redraw = True
        world_data["turn"] = int(turn_string)
        world_data["lifepoints"] = int(worldstate_file.readline())
        world_data["satiation"] = int(worldstate_file.readline())
        world_data["inventory"] = []
        while True:
            line = worldstate_file.readline().replace("\n", "")
            if line == '%':
                break
            world_data["inventory"] += [line]
        world_data["avatar_position"][0] = int(worldstate_file.readline())
        world_data["avatar_position"][1] = int(worldstate_file.readline())
        if not world_data["look_mode"]:
            world_data["map_center"][0] = world_data["avatar_position"][0]
            world_data["map_center"][1] = world_data["avatar_position"][1]
        world_data["map_size"] = int(worldstate_file.readline())
        world_data["fov_map"] = ""
        for i in range(world_data["map_size"]):
            line = worldstate_file.readline().replace("\n", "")
            world_data["fov_map"] += line
        world_data["mem_map"] = ""
        for i in range(world_data["map_size"]):
            line = worldstate_file.readline().replace("\n", "")
            world_data["mem_map"] += line
    worldstate_file.close()
read_worldstate.last_checked_mtime = -1


def read_message_queue():
    while (len(message_queue["messages"]) > 1
        or (len(message_queue["messages"]) == 1
            and not message_queue["open_end"])):
        message = message_queue["messages"].pop(0)
        if message == "THINGS_HERE START":
            read_message_queue.parse_thingshere = True
            world_data["look"] = []
        elif message == "THINGS_HERE END":
            read_message_queue.parse_thingshere = False
            if world_data["look"] == []:
                world_data["look"] = ["(none known)"]
            cursed_main.redraw = True
        elif read_message_queue.parse_thingshere:
            world_data["look"] += [message]
        elif message[0:4] == "LOG ":
            world_data["log"] += [message[4:]]
            cursed_main.redraw = True
        elif message == "WORLD_UPDATED":
            query_mapcell()
read_message_queue.parse_thingshere = False


def cursed_main(stdscr):

    def ping_test():
        half_wait_time = 5
        if len(new_data_from_server) > 0:
            ping_test.sent = False
        elif ping_test.wait_start + half_wait_time < time.time():
            if not ping_test.sent:
                io["file_out"].write("PING\n")
                io["file_out"].flush()
                ping_test.sent = True
                ping_test.wait_start = time.time()
            elif ping_test.sent:
                raise SystemExit("Server not answering anymore.")
    ping_test.wait_start = 0

    def read_into_message_queue():
        if new_data_from_server == "":
            return
        new_open_end = False
        if new_data_from_server[-1] is not "\n":
            new_open_end = True
        new_messages = new_data_from_server.splitlines()
        if message_queue["open_end"]:
            message_queue["messages"][-1] += new_messages[0]
            del new_messages[0]
        message_queue["messages"] += new_messages
        if new_open_end:
            message_queue["open_end"] = True

    curses.noecho()
    curses.curs_set(False)
    signal.signal(signal.SIGWINCH,
        lambda ignore_1, ignore_2: set_window_geometries())
    set_window_geometries()
    delay = 1
    while True:
        stdscr.timeout(int(delay))
        delay = delay * 1.1 if delay < 1000 else delay
        if cursed_main.redraw:
            delay = 1
            draw_screen()
            cursed_main.redraw = False
        char = stdscr.getch()
        if char >= 0:
            char = chr(char)
            if char in commands:
                if len(commands[char]) == 1 or not world_data["look_mode"]:
                    commands[char][0]()
                    cursed_main.redraw = True
                else:
                    commands[char][1]()
                    cursed_main.redraw = True
        new_data_from_server = io["file_in"].read()
        ping_test()
        read_into_message_queue()
        read_worldstate()
        read_message_queue()


message_queue = {
    "open_end": False,
    "messages": []
}
sep_size = 1  # Width of inter-window borders and title bars.
stdscr = None
screen_size = [0,0]
windows = []

try:
    if (not os.access(io["path_out"], os.F_OK)):
        msg = "No server input file found at " + io["path_out"] + "."
        raise SystemExit(msg)
    io["file_out"] = open(io["path_out"], "a")
    io["file_in"] = open(io["path_in"], "r")
    curses.wrapper(cursed_main)
except SystemExit as exit:
    print("ABORTING: " + exit.args[0])
except:
    print("SOMETHING WENT WRONG IN UNEXPECTED WAYS")
    raise
finally:
    if "file_out" in io:
        io["file_out"].close()
    if "file_in" in io:
        io["file_in"].close()
